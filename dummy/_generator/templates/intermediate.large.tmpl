import { Scope, SourceCode } from "eslint";
import { Identifier, VariableDeclarator } from "estree";

import { primary[[nextIndex]] } from "[[nextFile]]";

export async function primary[[index]](): Promise<string> {
  const a = await primary[[nextIndex]]();
  const second = secondary(a);

  const test = second;
  return test;
}

/*
 * UNUSED
 */
export function getAssignmentType(
  scope: Scope.Scope,
  variable: Scope.Variable
): "import" | "parameter" | "function" | "variable" | undefined {
  if (
    (variable.defs[0]?.node as VariableDeclarator).init?.type ===
    "CallExpression"
  ) {
    return "function";
  }

  if ((variable.defs[0]?.node.init as Identifier)?.type === "Identifier") {
    return "variable";
  }

  if (variable?.defs[0]?.type === "Parameter") {
    return "parameter";
  }

  // Hardcoded to assume function - i.e. get function name -
  // check if it is exist as a global import
  const importName = variable.defs[0]?.node?.init?.argument?.callee?.name;
  const importRef = scope.references.find(
    (it) => it.identifier.name === importName
  );

  if (importRef) {
    return "import";
  }
}

function secondary(input: string): string {
  const tmp = tertiary("unused", input);

  return tmp;
}

/*
 * UNUSED
 */
export function getFunctionScopeByName(
  sourceCode: SourceCode,
  functionName: string
): Scope.Scope | undefined {
  return sourceCode.scopeManager.scopes.find(
    (it) =>
      it.block.type === "FunctionDeclaration" &&
      it.block.id?.name === functionName
  );
}

function tertiary(input1: string, input2: string): string {
  const intermediate = input2;

  return intermediate;
}

/** FILLER */
enum Types {
  SINGLETON,
  SCOPED,
  TRANSIENT,
}

type Value<V = unknown> = {
  type?: Types;
  value: () => V;
};
type SubContainerWrapper<SC = SubContainer> = {
  isAsync: boolean;
  container: () => SC | Promise<SC>;
};

type UnwrapValue<WV> = WV extends Value
  ? WV["value"] extends () => infer V
    ? V extends string
      ? string
      : V extends number
      ? number
      : V
    : WV
  : WV;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type RestorePromise<T, V> = V extends Promise<any> ? Promise<T> : T;
type Unwrap<W> = W extends () => infer V ? V : W;
type Unpromisify<V> = V extends Promise<infer R> ? R : V;

type SubContainer = Container;
type SubContainers<
  K extends string | number | symbol = string | number | symbol
> = Record<K, SubContainerWrapper<SubContainer>>;
type OwnValues = Record<string, unknown>;

type PublicOwnValues<OV extends OwnValues> = {
  [key in keyof OV]: UnwrapValue<OV[key]>;
};

type SubContainerValues<SCS extends SubContainers | undefined> = {
  [key in keyof SCS]: SCS extends SubContainers
    ? RestorePromise<
        Unpromisify<Unwrap<SCS[key]["container"]>> extends Container<
          infer SSCS,
          infer SOV
        >
          ? PublicOwnValues<SOV> &
              (PublicAllValues<SSCS, SOV> extends never
                ? Record<string, unknown>
                : PublicAllValues<SSCS, SOV>)
          : undefined,
        Unwrap<SCS[key]["container"]>
      >
    : undefined;
};

export type PublicAllValues<
  SCS extends SubContainers | undefined,
  OV extends OwnValues
> = PublicOwnValues<OV> & SubContainerValues<SCS>;

export class Container<
  SCS extends SubContainers | undefined = SubContainers | undefined,
  OV extends OwnValues = OwnValues
> {
  public subContainers: SCS | undefined;
  public ownValues: OV | undefined;
  public publicValues: PublicAllValues<SCS, OV>;

  constructor(values?: OV, subContainers?: SCS) {
    this.subContainers = subContainers;
    this.ownValues = values;
    this.publicValues = {} as PublicAllValues<SCS, OV>;

    for (const [key, ownValue] of Object.entries(values ?? {})) {
      if (!isValue(ownValue)) {
        continue;
      }

      Object.defineProperty(this.publicValues, key, {
        get: () => {
          if (!this.ownValues) {
            throw new Error("Unable to access own values!");
          }

          const val = this.ownValues[key] as Value;

          return val.value();
        },
      });
    }

    for (const [key, subContainerResolver] of Object.entries(
      subContainers ?? {}
    )) {
      if (subContainerResolver.isAsync) {
        Object.defineProperty(this.publicValues, key, {
          get: async () => {
            const subContainer = await subContainerResolver.container();
            return subContainer.publicValues;
          },
        });
      } else {
        const resolvedSubContainer =
          subContainerResolver.container() as SubContainer;

        Object.defineProperty(this.publicValues, key, {
          get: () => resolvedSubContainer.publicValues,
        });
      }
    }
  }

  public async getContainer<KS extends keyof SCS>(
    containerKey: KS
  ): Promise<
    SCS[KS] extends SubContainerWrapper
      ? Unwrap<SCS[KS]["container"]>
      : undefined
  > {
    if (!this.subContainers) {
      throw new Error("Attempting to access subcontainer that does not exist!");
    }

    return (await this.subContainers[
      containerKey
    ]?.container()) as unknown as SCS[KS] extends SubContainerWrapper
      ? Unwrap<SCS[KS]["container"]>
      : undefined;
  }

  public replaceValue<K extends keyof OV>(
    key: K,
    newValue: UnwrapValue<OV[K]>
  ): void {
    if (!this.ownValues) {
      throw new Error(
        "Unable to update value on container, key does not refer to a value"
      );
    }

    const prevValue = this.ownValues[key] as Value;

    this.ownValues[key] = {
      type: prevValue.type,
      value: () => newValue,
    } as OV[K];
  }

  public preloadWhenIdle(): void {
    if (typeof window === "undefined") {
      return;
    }

    let index = 0;
    const keys = Object.keys(this.subContainers ?? {});

    const preload = (): void => {
      if (index === keys.length || !this.subContainers) {
        return;
      }

      const subContainer = this.subContainers[keys[index] ?? 0];

      if (!subContainer?.isAsync) {
        index++;
        preload();

        return;
      } else {
        subContainer.container();
        index++;
      }
    };

    window.requestIdleCallback(() => {
      preload();

      if (index < keys.length) {
        window.requestIdleCallback(() => {
          if (index < keys.length) {
            preload();
          }
        });
      }
    });
  }
}

function isValue(val: unknown): val is Value {
  return typeof val === "object" && val != null && "value" in val;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type OmitFirstArg<F> = F extends (x: any, ...args: infer P) => unknown
  ? P
  : unknown;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function rawInject<C extends Container, F extends (...args: any[]) => any>(
  container: C,
  func: F
): (...args: OmitFirstArg<F>) => ReturnType<F> {
  return (...args: OmitFirstArg<F>): ReturnType<F> => {
    return func(container.publicValues, ...args);
  };
}

export function createInjector<C extends Container>(
  container: C
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
): <F extends (dep: C["publicValues"], ...args: any[]) => any>(
  func: F
) => (...args: OmitFirstArg<F>) => ReturnType<F> {
  return (func) => rawInject(container, func);
}

export type FunctionCallMsg = {
  requestId: number;
  args: unknown[];
  functionName: string;
  fileName: string;
};

export type FunctionCallResultMsg = {
  requestId: number;
  res: unknown;
};

export function isFunctionCallMsg(msg: unknown): msg is FunctionCallMsg {
  return (
    typeof msg === "object" &&
    msg !== null &&
    "args" in msg &&
    "functionName" in msg &&
    "fileName" in msg &&
    "requestId" in msg
  );
}

export function isFunctionCallResultMsg(
  msg: unknown
): msg is FunctionCallResultMsg {
  return (
    typeof msg === "object" &&
    msg !== null &&
    "requestId" in msg &&
    "res" in msg
  );
}

export type DeferredPromise<R = void> = Promise<R> & {
  resolve(val: R): void;
  reject(reason: unknown): void;
};

/**
 * Creates an extended promise object, exposing .resolve() and .reject()
 * publicly.
 *
 * If given, the promise will be rejected if it's not resolved before the
 * timeout.
 */
export function DeferredPromise<R = void>(
  timeout?: number
): DeferredPromise<R> {
  let resolve: (value: R | PromiseLike<R>) => void;
  let reject: (value: unknown) => void;
  let timeoutId: number | undefined;

  // @ts-expect-error TS doesn't know that we'll be adding public
  // promise.resolve and promise.reject inside the callback
  const promise: DeferredPromise<R> = new Promise(
    (internalResolve, internalReject) => {
      resolve = internalResolve;
      reject = internalReject;
      timeoutId = timeout
        ? window.setTimeout(internalReject, timeout)
        : undefined;
    }
  );

  promise.resolve = (val: R) => {
    resolve(val);

    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  };

  promise.reject = (reason?: unknown) => {
    reject(reason);

    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  };

  return promise;
}
